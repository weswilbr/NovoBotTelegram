# NOME DO ARQUIVO: features/products/handlers.py
# REFACTOR: Totalmente reescrito para usar a nova estrutura de dados 'PRODUTOS'
#           e com melhorias de usabilidade, como pagina√ß√£o.

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

from .data import PRODUTOS
from utils.anti_flood import command_rate_limit

logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# Configura√ß√µes
# --------------------------------------------------------------------------- #
ITEMS_PER_PAGE = 6          # bot√µes por p√°gina

# --------------------------------------------------------------------------- #
# /produtos ‚Üí primeira p√°gina
# --------------------------------------------------------------------------- #
@command_rate_limit
async def beneficiosprodutos(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Exibe a primeira p√°gina do menu de produtos."""
    await send_product_menu_page(update, context, page=0)

# --------------------------------------------------------------------------- #
# Fun√ß√µes de menu / pagina√ß√£o
# --------------------------------------------------------------------------- #
async def send_product_menu_page(
    update: Update, context: ContextTypes.DEFAULT_TYPE, page: int = 0
) -> None:
    """Envia uma p√°gina espec√≠fica do menu de produtos."""
    query = update.callback_query

    if not PRODUTOS:
        text = "‚ö†Ô∏è Nenhum produto foi encontrado. Verifique a configura√ß√£o."
        if query:
            await query.message.edit_text(text)
        elif update.message:
            await update.message.reply_text(text)
        return

    product_keys = sorted(PRODUTOS.keys())
    start, end = page * ITEMS_PER_PAGE, (page + 1) * ITEMS_PER_PAGE
    page_items = product_keys[start:end]

    keyboard, row = [], []
    for key in page_items:
        row.append(
            InlineKeyboardButton(
                PRODUTOS[key]["label"],
                callback_data=f"prod_details_{key}",
            )
        )
        if len(row) == 2:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)

    # navega√ß√£o
    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"prod_page_{page-1}"))
    if end < len(product_keys):
        nav.append(InlineKeyboardButton("Pr√≥xima ‚û°Ô∏è", callback_data=f"prod_page_{page+1}"))
    if nav:
        keyboard.append(nav)

    reply_markup = InlineKeyboardMarkup(keyboard)
    text = "Selecione um produto para ver os detalhes:"

    if query:
        await query.answer()
        await query.message.edit_text(text, reply_markup=reply_markup)
    elif update.message:
        await update.message.reply_text(text, reply_markup=reply_markup)

# --------------------------------------------------------------------------- #
# Roteador de callbacks
# --------------------------------------------------------------------------- #
async def products_callback_router(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Roteia todos os callbacks que come√ßam com 'prod_'."""
    query = update.callback_query
    if not (query and query.data):
        return

    data = query.data

    if data.startswith("prod_page_"):
        await send_product_menu_page(update, context, page=int(data.split("_")[-1]))

    elif data.startswith("prod_details_"):
        await show_product_details(update, context, product_key=data.split("_")[-1])

    elif data.startswith("prod_media_"):
        _, _, key, media_type = data.split("_")
        await send_product_media(update, context, key, media_type)

    elif data.startswith("prod_pitch_"):
        await send_product_pitch(update, context, product_key=data.split("_")[-1])

    elif data.startswith("prod_social_"):
        await send_social_kit(update, context, product_key=data.split("_")[-1])

# --------------------------------------------------------------------------- #
# ALIAS LEGADO  -> linha crucial para o ImportError desaparecer
# --------------------------------------------------------------------------- #
products_callback_handler = products_callback_router  # N√ÉO REMOVA

# --------------------------------------------------------------------------- #
# Fun√ß√µes auxiliares
# --------------------------------------------------------------------------- #
async def show_product_details(
    update: Update, context: ContextTypes.DEFAULT_TYPE, product_key: str
) -> None:
    """Exibe o submenu de um produto."""
    query = update.callback_query
    product = PRODUTOS.get(product_key)

    if not (product and query and query.message):
        if query:
            await query.answer("‚ö†Ô∏è Produto n√£o encontrado.", show_alert=True)
        return

    caption = (
        f"Voc√™ selecionou: *{product['label']}*\n\n"
        "Escolha uma op√ß√£o:"
    )

    keyboard = []
    media = product.get("media", {})

    # bot√µes de m√≠dia
    media_btns = []
    if media.get("video"):
        media_btns.append(InlineKeyboardButton("üé¨ V√≠deo", callback_data=f"prod_media_{product_key}_video"))
    if media.get("documento"):
        media_btns.append(InlineKeyboardButton("üìÑ Folheto", callback_data=f"prod_media_{product_key}_documento"))
    if media_btns:
        keyboard.append(media_btns)

    # bot√µes adicionais
    other = []
    if product.get("pitch"):
        other.append(InlineKeyboardButton("üí∞ Pitch Venda", callback_data=f"prod_pitch_{product_key}"))
    if product.get("social_kit"):
        other.append(InlineKeyboardButton("üì≤ Kit Social", callback_data=f"prod_social_{product_key}"))
    if other:
        keyboard.append(other)

    keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data="prod_page_0")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    photo_id = media.get("foto")
    if photo_id:
        await query.message.delete()
        await context.bot.send_photo(
            chat_id=query.message.chat_id,
            photo=photo_id,
            caption=caption,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup,
        )
    else:
        await query.message.edit_text(caption, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

async def send_product_media(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    product_key: str,
    media_type: str,
) -> None:
    """Envia v√≠deo ou documento do produto."""
    query = update.callback_query
    await query.answer()

    product = PRODUTOS.get(product_key)
    chat_id = query.message.chat_id
    media_id = product.get("media", {}).get(media_type)

    if not media_id:
        await context.bot.send_message(chat_id, f"‚ö†Ô∏è M√≠dia '{media_type}' n√£o encontrada.")
        return

    try:
        if media_type == "video":
            await context.bot.send_video(chat_id=chat_id, video=media_id)
        elif media_type == "documento":
            await context.bot.send_document(chat_id=chat_id, document=media_id)
    except Exception as e:
        logger.error("Erro ao enviar m√≠dia %s/%s: %s", product_key, media_type, e)
        await context.bot.send_message(chat_id, "Ocorreu um erro ao enviar a m√≠dia.")

async def send_product_pitch(
    update: Update, context: ContextTypes.DEFAULT_TYPE, product_key: str
) -> None:
    query = update.callback_query
    await query.answer()

    pitch = PRODUTOS.get(product_key, {}).get("pitch")
    if pitch:
        await query.message.reply_text(pitch, parse_mode=ParseMode.MARKDOWN)
    else:
        await query.message.reply_text("‚ö†Ô∏è Pitch de venda n√£o encontrado.")

async def send_social_kit(
    update: Update, context: ContextTypes.DEFAULT_TYPE, product_key: str
) -> None:
    query = update.callback_query
    await query.answer()

    kit = PRODUTOS.get(product_key, {}).get("social_kit")
    if not kit:
        await query.message.reply_text("‚ö†Ô∏è Kit de M√≠dias Sociais n√£o encontrado.")
        return

    text = (
        "üì≤ *Kit de M√≠dias Sociais*\n\n"
        "*Texto Sugerido (copie e cole):*\n"
        f"`{kit.get('copy_text', 'N/A')}`\n\n"
        "*Hashtags Sugeridas (copie e cole):*\n"
        f"`{kit.get('hashtags', 'N/A')}`"
    )
    await query.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

# --------------------------------------------------------------------------- #
# Export expl√≠cito
# --------------------------------------------------------------------------- #
__all__ = [
    "beneficiosprodutos",
    "products_callback_router",
    "products_callback_handler",
]